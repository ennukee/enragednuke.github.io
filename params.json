{
  "name": "enragednuke",
  "tagline": "personal github website",
  "body": "# Absolutely Basics of R\r\n\r\n[Index page](https://github.com/enragednuke/R-language-cheatsheet/blob/master/README.md)\r\n\r\n## Installing packages\r\n\r\n```R\r\ninstall.packages()\r\n# ( you will be prompted to select a mirror to download from once per session )\r\n# ( then you will be prompted for to select a package )\r\n```\r\n\r\nYou should also be able to do this:\r\n\r\n```R\r\ninstall.packages('package_name')\r\n```\r\n\r\nSo you should do this first before anything else:\r\n\r\n```R\r\ninstall.packages('dplyr')\r\ninstall.packages('tidyr')\r\ninstall.packages('ggplot2')\r\n```\r\n\r\n## Importing packages\r\n\r\n```R\r\nlibrary(package_name)\r\n\r\n# So, you'll want this at the top of your scripts:\r\nlibrary(dplyr)\r\nlibrary(tidyr)\r\nlibrary(ggplot2)\r\n```\r\n\r\n## Fundamental basics\r\n\r\nRead this: http://www.r-tutor.com/r-introduction. It contains almost **every** basic programming methodlogy you may think of googling from other languages (like making arrays, length of str/array, etc). You can just skim and look at code bits if it's too long to read fully.\r\n\r\nYou should be familiar with the syntax: `c(args*)` (used **very** often), `is.class_name(object)`, `sprintf(str, args*)`, `substr(str, start=int, stop=int)`, `sub(to_replace, replace_with, str)`, `paste(str, str)`, `class(object)`. Most of these will be very straight forward and won't need any real reading on your part, just know they exist and they're usage syntax.\r\n\r\nNote: R treats the class `character` the same as `string`. So `is.character('abc')` will yield `TRUE`.\r\n\r\n<details>\r\n<summary>Conditionals:</summary>\r\n\r\n|Symbol|Meaning|\r\n|---|---|\r\n|`|`|OR|\r\n|`&`|AND|\r\n|`!`|NOT|\r\n\r\n</details>\r\n\r\n### Vector logic\r\n\r\nIn R, the objects known as **Vectors** are basically just arrays from any other language in existence. **VERY IMPORTANT NOTE: Indices in R start at ONE, NOT ZERO!**\r\n\r\nYou can generate them using the syntax `c(args*)` which makes an array with contents `args*` so for example: `c(1,2,3)` = `[1, 2, 3]`. You can also use the `c(args*)` method to concatenate two vectors together, so `c(c(1,2,3), c(3,4,5))` = `[1, 2, 3, 3, 4, 5]`.\r\n\r\nI **highly recommend** viewing the Vector portion of the guide I posted above. It will be extremely helpful in understanding how vector logic works. For example: adding (using `+`) two vectors together will not concatenate them, it will add the contents together. So `c(1,2,3) + c(3,4,5)` = `[4, 6, 8]`. Multiplying a vector will multiply its contents.\r\n\r\nAn important rule is known as the **recycling rule**. Operating on two vectors of different length will extend the shorter vector using its own values again. For example: `c(1,2,3) + c(3,4,5,6,7,8,9)` is essentially doing `c(1,2,3,1,2,3,1) + c(3,4,5,6,7,8,9)`.\r\n\r\n<details>\r\n<summary>**Nifty trick**: What will `c(1, -1) * c(1, 2, 4, 8, 16, 32)` create?</summary>\r\n`[1, -2, 4, -8, 16, -32]`\r\naka an alternating sequence!\r\n</details>\r\n\r\n**Be careful with negative indices**. Unlike other languages, negative indices will **not** search from the back of an array. So `array[-1]` will not return the last value of an array. Negative indices will instead return the vector with the item at the absolute value of the index removed.\r\n\r\n<details>\r\n<summary>Code example</summary>\r\n```R\r\n> a = c(1, 2, 3, 4)\r\n> a\r\n[1, 2, 3, 4]\r\n> a[-1]\r\n[2, 3, 4]\r\n> a[-3]\r\n[1, 2, 4]\r\n```\r\n</details>\r\n\r\n### Matrices\r\n\r\nIn **R**, there are data types known as **Matrices**. They're a more convenient way of representing 2-dimensional arrays. You can supply a large feed of values and then specify specific column and row values to restrict it. You can then refer to it like a normal 2D array (i.e. `(c[x, y])`).\r\n\r\nIt is done using the `matrix(data_vector, nrow=int, ncol=int, byrow=TRUE)` method.\r\n\r\n<details>\r\n<summary>Code example</summary>\r\n```R\r\nA = matrix(\r\n  c(1, 2, 3, 4, 5, 6),\r\n  nrow=2,\r\n  ncol=3,\r\n  byrow=TRUE)\r\n```\r\n\r\nGenerates the following table:\r\n\r\n```\r\n1 2 3\r\n4 5 6\r\n```\r\n</details>\r\n\r\nWe can supply the matrix/table with labels using `rownames(matrix)`, `colnames(matrix)`, or `dimnames(matrix)`. The first and second take in a single vector as their equality (you call these using `method = val`, not using another param) while the third takes in a list of column names and row names.\r\n\r\n<details>\r\n<summary>Code example</summary>\r\n```R\r\ndimnames(A) = list(\r\n            c('row1', 'row2'),\r\n            c('col1', 'col2', 'col3'))\r\n```\r\n\r\nThis produces:\r\n\r\n||col1|col2|col3|\r\n|---|---|---|---|\r\n|**row1**|1|2|3|\r\n|**row2**|4|5|6|\r\n</details>\r\n\r\nOnce you label the column/row names, you can reference values at certain indices using those names (using the example result, `A['row2', 'col1']` = `4`)\r\n\r\nYou can combine matrices using `cbind(m1, m2)` (if equal rows) or `rbind(m1, m2)` (if equal columns). Backwards, but it makes sense because `cbind` binds by attaching `m2` to the right side of `m1`. This is only possible if they have equal row counts. Same applies for `rbind` which attaching `m2` to the bottom of `m1`.\r\n\r\nYou can also output the contents as a single vector using `c(matrix)`\r\n\r\n## Data Frame\r\n\r\nYou can generate a table using `data.frame(args*)` where `args*` represents a series of `col=vector` arguments.\r\n\r\n```R\r\ntbl <- data.frame(col1 = c(1,2,4,3), col2 = c('a','c','d','e'))\r\ntbl\r\n```\r\nThe result (note that the far left column is a sort of `id` column:\r\n\r\n||col1|col2|\r\n|---|---|---|\r\n|*1*|1|'a'|\r\n|*2*|2|'c'|\r\n|*3*|4|'d'|\r\n|*4*|3|'e'|\r\n\r\nTake note that the variable names for the vectors become the actual column names (plan ahead!)\r\n\r\nWhen working with a data table, you can look at strictly the columns by doing this: `table[[index]]`, `table[[col_name]]`, or `table[,col_name]`. This will return a vector of the values in that column.\r\n\r\nYou can slice the columns (i.e. return the column name and the row names in the table) by doing `table[index]` or `table[col_name]`. You can also view multiple columns using a vector, i.e. `table[c(col_name1, col_name2, ...)]`.\r\n\r\nTo slice specific **rows**, however, you use `table[index,]` or `table[row_name,]`. Similarly, you can pass a vector instead (just lke column slicing). Interestingly enough, you can also use **logical indexing**. It's a pseudo-filter. Example: `table[table$col_name == 'hello',]` or `table[table$count > 5,]`. You can then chain it into another slice/strict slice like this: `table[table$count > 5]$swagamt`. That will return a vector of the `swagamt` values of rows in `table` with a `count` of higher than 5.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}